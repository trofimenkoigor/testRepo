#!/bin/bash

var1=abcd-1234-defg
echo "var1 = $var1"

t=${var1#*-*}
echo "var1 (все, от начала строки по первый символ \"-\", включительно, удаляется) = $t"
#  t=${var1#*-}  то же самое,
#+ поскольку оператор # ищет кратчайшее совпадение,
#+ а * соответствует любым предшествующим символам, включая пустую строку.
# (Спасибо S. C. за разъяснения.)

t=${var1##*-*}
echo "Если var1 содержит \"-\", то возвращается пустая строка...   var1 = $t"


t=${var1%*-*}
echo "var1 (все, начиная с последнего \"-\" удаляется) = $t"

echo

# -------------------------------------------
path_name=/home/bozo/ideas/thoughts.for.today
# -------------------------------------------

echo "path_name = $path_name"
t=${path_name##/*/}
echo "Из path_name удален путь к файлу = $t"
#  В данном случае, тот эе эффект можно получить так:  t=`basename $path_name`
#  t=${path_name%/}; t=${t##*/}   более общее решение,
#+ но имеет некоторые ограничения.
#  Если $path_name заканчивается символом перевода строки, то `basename $path_name` не будет работать,
#+ но для данного случая вполне применимо.
# (Спасибо S.C.)

t=${path_name%/*.*}
# Тот же эффект дает    t=`dirname $path_name`
echo "Из path_name удалено имя файла = $t"
# Этот вариант будет терпеть неудачу в случаях: "../", "/foo////", # "foo/", "/".
#  Удаление имени файла, особенно когда его нет,
#+ использование dirname имеет свои особенности.
# (Спасибо S.C.)

echo

t=${path_name:11}
echo "Из $path_name удалены первые 11 символов = $t"
t=${path_name:11:5}
echo "Из $path_name удалены первые 11 символов, выводится 5 символов = $t"

echo

t=${path_name/bozo/clown}
echo "В $path_name подстрока \"bozo\" заменена на \"clown\" = $t"
t=${path_name/today/}
echo "В $path_name подстрока \"today\" удалена = $t"
t=${path_name//o/O}
echo "В $path_name все символы \"o\" переведены в верхний регистр, = $t"
t=${path_name//o/}
echo "Из $path_name удалены все символы \"o\" = $t"

exit 0

